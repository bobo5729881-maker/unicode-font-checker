<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Unicode Font Checker</title>

  <!-- LINE-ish style (no build) -->
  <style>
    :root{
      --line:#06C755;
      --bg:#F6F7F9;
      --card:#ffffff;
      --ink:#111827;
      --muted:#6B7280;
      --ring: rgba(6,199,85,.22);
      --shadow: 0 10px 30px rgba(17,24,39,.08);
      --shadow2: 0 6px 16px rgba(17,24,39,.08);
      --radius: 18px;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "PingFang TC", "Microsoft JhengHei", "Noto Sans CJK TC", "Noto Sans CJK SC", Arial, sans-serif;
      color:var(--ink);
      background:
        radial-gradient(1200px 600px at 15% -10%, rgba(6,199,85,.16), transparent 60%),
        radial-gradient(900px 500px at 95% 10%, rgba(59,130,246,.12), transparent 55%),
        radial-gradient(900px 600px at 20% 110%, rgba(236,72,153,.10), transparent 55%),
        var(--bg);
    }
    a{ color: inherit; }
    .wrap{ max-width: 1100px; margin: 0 auto; padding: 22px 16px 60px; }
    .topbar{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px; margin-bottom: 16px;
    }
    .brand{
      display:flex; align-items:center; gap:12px;
      padding: 12px 14px; background: rgba(255,255,255,.7);
      border: 1px solid rgba(17,24,39,.08);
      border-radius: 999px;
      box-shadow: var(--shadow2);
      backdrop-filter: blur(10px);
    }
    .logo{
      width:38px; height:38px; border-radius: 12px;
      background: linear-gradient(135deg, rgba(6,199,85,1), rgba(16,185,129,1));
      display:grid; place-items:center;
      color:white; font-weight:900;
      box-shadow: 0 10px 20px rgba(6,199,85,.25);
    }
    .brand h1{ font-size: 16px; margin:0; line-height: 1.2; }
    .brand p{ margin:0; font-size: 12px; color: var(--muted); }

    .grid{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap: 16px;
      align-items: start;
    }
    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
    }
    .card{
      background: rgba(255,255,255,.78);
      border: 1px solid rgba(17,24,39,.08);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 16px;
      backdrop-filter: blur(10px);
    }
    .card h2{
      margin: 0 0 10px 0;
      font-size: 15px;
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
    }
    .pill{
      font-size: 12px; color: #065f46;
      background: rgba(6,199,85,.12);
      border: 1px solid rgba(6,199,85,.24);
      padding: 5px 10px; border-radius: 999px;
      white-space: nowrap;
    }
    .muted{ color: var(--muted); font-size: 13px; line-height: 1.55; }

    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .row > *{ flex: 0 0 auto; }
    input[type="file"]{ display:none; }
    .btn{
      border: 0;
      padding: 10px 12px;
      border-radius: 14px;
      font-weight: 700;
      cursor:pointer;
      transition: transform .05s ease, box-shadow .12s ease;
      display:inline-flex; align-items:center; gap:8px;
      user-select:none;
    }
    .btn:active{ transform: translateY(1px); }
    .btn-primary{
      background: linear-gradient(135deg, rgba(6,199,85,1), rgba(16,185,129,1));
      color: white;
      box-shadow: 0 10px 22px rgba(6,199,85,.22);
    }
    .btn-soft{
      background: rgba(17,24,39,.06);
      color: var(--ink);
      border: 1px solid rgba(17,24,39,.08);
    }
    .btn-warn{
      background: linear-gradient(135deg, rgba(249,115,22,1), rgba(245,158,11,1));
      color: white;
      box-shadow: 0 10px 22px rgba(245,158,11,.18);
    }
    .btn:disabled{ opacity:.55; cursor:not-allowed; box-shadow:none; }

    .preview{
      margin-top: 12px;
      display:grid; gap:10px;
      grid-template-columns: 1fr;
    }
    .imgbox{
      width:100%;
      border-radius: 16px;
      overflow:hidden;
      border: 1px solid rgba(17,24,39,.10);
      background: rgba(255,255,255,.65);
      box-shadow: var(--shadow2);
    }
    .imgbox img{ width:100%; display:block; max-height: 360px; object-fit: contain; background: white; }
    .mini{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      background: rgba(17,24,39,.06);
      padding: 4px 8px; border-radius: 10px;
      border: 1px solid rgba(17,24,39,.08);
    }
    .status{
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 16px;
      border: 1px solid rgba(17,24,39,.08);
      background: rgba(255,255,255,.7);
    }
    .status strong{ font-size: 13px; }
    .status .muted{ margin-top: 2px; }

    .input{
      width: 100%;
      padding: 12px 12px;
      border-radius: 14px;
      border: 1px solid rgba(17,24,39,.12);
      outline: none;
      background: rgba(255,255,255,.85);
      box-shadow: 0 0 0 0 transparent;
      transition: box-shadow .12s ease, border-color .12s ease;
      font-size: 14px;
    }
    .input:focus{
      border-color: rgba(6,199,85,.35);
      box-shadow: 0 0 0 5px var(--ring);
    }
    .split{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .candidates{
      margin-top: 12px;
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap: 12px;
    }
    @media (max-width: 700px){
      .candidates{ grid-template-columns: 1fr; }
    }
    .cand{
      border-radius: 18px;
      border: 1px solid rgba(17,24,39,.08);
      background: rgba(255,255,255,.86);
      box-shadow: var(--shadow2);
      padding: 12px;
      display:grid;
      gap: 10px;
    }
    .candTop{
      display:flex; justify-content:space-between; align-items:flex-start; gap: 10px;
    }
    .bigChar{
      font-size: 52px;
      line-height: 1;
      letter-spacing: .02em;
      user-select:text;
      padding: 6px 8px;
      border-radius: 14px;
      background: linear-gradient(135deg, rgba(6,199,85,.10), rgba(59,130,246,.08));
      border: 1px solid rgba(17,24,39,.06);
      width: fit-content;
    }
    .meta{
      font-size: 12px;
      color: var(--muted);
      text-align:right;
    }
    .fonts{
      display:grid; gap: 8px;
    }
    .fontLine{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      padding: 8px 10px;
      border-radius: 14px;
      border: 1px solid rgba(17,24,39,.07);
      background: rgba(17,24,39,.03);
    }
    .fontName{
      font-size: 12px;
      color: rgba(17,24,39,.78);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 55%;
    }
    .sample{
      font-size: 24px;
      line-height: 1;
      user-select:text;
      padding: 4px 8px;
      border-radius: 12px;
      background: rgba(255,255,255,.65);
      border: 1px solid rgba(17,24,39,.06);
    }
    .tag{
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(17,24,39,.10);
      background: rgba(255,255,255,.85);
      color: rgba(17,24,39,.72);
    }

    .feedback{
      margin-top: 14px;
      padding: 12px;
      border-radius: 18px;
      border: 1px dashed rgba(6,199,85,.35);
      background: rgba(6,199,85,.06);
      display:grid;
      gap: 10px;
    }
    .fbGrid{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .choice{
      border: 1px solid rgba(17,24,39,.10);
      background: rgba(255,255,255,.9);
      border-radius: 14px;
      padding: 8px 10px;
      cursor:pointer;
      display:flex; align-items:center; gap: 8px;
      box-shadow: 0 8px 16px rgba(17,24,39,.06);
      transition: transform .06s ease, box-shadow .12s ease;
      user-select:none;
    }
    .choice:hover{ transform: translateY(-1px); box-shadow: 0 12px 22px rgba(17,24,39,.08); }
    .choice .ch{ font-size: 22px; line-height: 1; }
    .choice .small{ font-size: 12px; color: var(--muted); }

    .footer{
      margin-top: 14px;
      color: rgba(17,24,39,.55);
      font-size: 12px;
      text-align:center;
    }
    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(17,24,39,.92);
      color: white;
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 13px;
      box-shadow: 0 14px 30px rgba(0,0,0,.20);
      opacity: 0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
    }
    .toast.show{ opacity:1; transform: translateX(-50%) translateY(-4px); }
  </style>

  <!-- Tesseract.js for OCR (pure front-end) -->
  <script defer src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <!-- Firebase (compat for simple <script> usage) -->
  <script defer src="https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js"></script>
  <script defer src="https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore-compat.js"></script>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="logo">å­—</div>
        <div>
          <h1>Unicode Font Checker</h1>
          <p>åœ–ç‰‡ OCR â†’ 10 å€‹å€™é¸å­— â†’ å¤šå­—å‹é¡¯ç¤º â†’ å¯è¤‡è£½ï½œå›é¥‹è¶Šç”¨è¶Šæº–</p>
        </div>
      </div>
      <div class="pill">LINE é¢¨æ ¼ Â· GitHub Pages å¯ç”¨</div>
    </div>

    <div class="grid">
      <!-- LEFT -->
      <div class="card">
        <h2>
          <span>1) ä¸Šå‚³æˆªåœ– OCR è¾¨è­˜</span>
          <span class="pill">æ¨è–¦ï¼šå­—è¦å¤ æ¸…æ¥šã€å°æ¯”é«˜</span>
        </h2>

        <div class="row">
          <label class="btn btn-primary" for="fileInput">ğŸ“· ä¸Šå‚³åœ–ç‰‡</label>
          <input id="fileInput" type="file" accept="image/*" />

          <button id="btnRecognize" class="btn btn-warn" disabled>âœ¨ é–‹å§‹è¾¨è­˜</button>
          <button id="btnRetry" class="btn btn-soft" disabled>ğŸ” é‡æ–°è¾¨è­˜</button>
        </div>

        <div class="preview">
          <div class="imgbox">
            <img id="previewImg" alt="preview" src="" style="display:none" />
          </div>

          <div class="mini">
            <span class="kbd">æç¤ºï¼šå¯ä»¥å…ˆè£åˆ‡åˆ°åªå‰©ä¸€å€‹å­—</span>
            <span class="kbd">æ”¯æ´ï¼šchi_tra / chi_sim / jpnï¼ˆæœƒåˆä½µå€™é¸ï¼‰</span>
          </div>

          <div class="status" id="statusBox">
            <strong id="statusTitle">å°šæœªä¸Šå‚³åœ–ç‰‡</strong>
            <div class="muted" id="statusText">ä¸Šå‚³å¾ŒæŒ‰ã€Œé–‹å§‹è¾¨è­˜ã€ï¼Œæœƒç”¢ç”Ÿ 10 å€‹ä¸åŒå€™é¸å­—ã€‚</div>
          </div>

          <canvas id="workCanvas" style="display:none"></canvas>
        </div>
      </div>

      <!-- RIGHT -->
      <div class="card">
        <h2>
          <span>2) æ‰‹å‹•è²¼ä¸Šå­— / ç¢¼ä½ï¼ˆå¦ä¸€å€‹å…¥å£ï¼‰</span>
          <span class="pill">è²¼ä¸ä¸Šä¹Ÿå¯ç”¨ U+XXXX</span>
        </h2>

        <div class="split">
          <div>
            <div class="muted" style="margin-bottom:6px">è²¼ä¸Šã€Œä½ æƒ³æª¢æŸ¥çš„å­—ã€ï¼ˆå¦‚æœèƒ½è²¼å°±è²¼ï¼›ä¸è¡Œå°±ç”¨ä¸‹é¢çš„ç¢¼ä½è¼¸å…¥ï¼‰</div>
            <input id="manualChar" class="input" placeholder="ä¾‹å¦‚ï¼šğ¢š æˆ– ğ ®Ÿï¼ˆå¯ç›´æ¥è²¼ï¼‰" />
          </div>

          <div>
            <div class="muted" style="margin-bottom:6px">æˆ–è¼¸å…¥ç¢¼ä½ï¼šæ”¯æ´ <span class="kbd">U+4E00</span> / <span class="kbd">4E00</span> / <span class="kbd">0x4E00</span></div>
            <input id="manualCode" class="input" placeholder="ä¾‹å¦‚ï¼šU+26D3F" />
          </div>

          <div class="row">
            <button id="btnManualShow" class="btn btn-primary">âœ… é¡¯ç¤ºä¸¦ç”¢ç”Ÿå€™é¸å¡ç‰‡</button>
            <button id="btnClear" class="btn btn-soft">ğŸ§¹ æ¸…ç©º</button>
          </div>

          <div class="status">
            <strong>èªªæ˜</strong>
            <div class="muted">
              é€™å€‹ç¶²ç«™æœƒç”¨ã€Œå¤šç¨®å¸¸è¦‹ç³»çµ±å­—å‹ã€å±•ç¤ºåŒä¸€å€‹å­—ï¼Œè®“ä½ å¿«é€Ÿåˆ¤æ–·ä½ é€™å°é›»è…¦æ˜¯å¦èƒ½é¡¯ç¤ºï¼›
              è‹¥ä½ åŠ ä¸Šè‡ªå·±çš„å­—å‹ï¼ˆPUA å­—å‹ï¼‰ä¹Ÿå¯ä»¥åœ¨é€™è£¡çœ‹æ•ˆæœã€‚
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- RESULTS -->
    <div class="card" style="margin-top:16px">
      <h2>
        <span>3) OCR å€™é¸å­—ï¼ˆ10 å€‹ä¸åŒå­—ï¼‰ï¼‹ å¤šå­—å‹é¡¯ç¤º ï¼‹ å¯è¤‡è£½</span>
        <span class="pill">é»å­—å³å¯è¤‡è£½</span>
      </h2>

      <div id="resultsInfo" class="muted">å°šç„¡çµæœã€‚ä¸Šå‚³åœ–ç‰‡æˆ–æ‰‹å‹•è¼¸å…¥å¾Œï¼Œæœƒåœ¨é€™è£¡å‡ºç¾å€™é¸å­—å¡ç‰‡ã€‚</div>

      <div id="candidates" class="candidates"></div>

      <div id="feedbackBox" class="feedback" style="display:none">
        <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap">
          <strong>ğŸŸ¢ è«‹é»é¸æœ€æ¥è¿‘çš„å­—ï¼ˆå›é¥‹å¾Œæœƒè¶Šç”¨è¶Šæº–ï¼‰</strong>
          <span class="muted">ä½ é»ä¸€æ¬¡ = è³‡æ–™åº«ç´¯ç©ä¸€æ¬¡ï¼ˆä¸ç”¨ä½ æ‰‹å‹•æ•´ç†ï¼‰</span>
        </div>
        <div id="fbChoices" class="fbGrid"></div>

        <div style="display:grid; gap:8px">
          <div class="muted">å¦‚æœã€Œä»¥ä¸Šéƒ½ä¸æ˜¯ã€ï¼Œä½ å¯ä»¥ç›´æ¥è¼¸å…¥æ­£ç¢ºå­—æˆ–ç¢¼ä½ï¼ˆU+XXXXï¼‰ï¼š</div>
          <div class="row" style="width:100%">
            <input id="fbCustom" class="input" style="flex:1 1 320px" placeholder="ä¾‹å¦‚ï¼šğ¢š æˆ– U+26D3F" />
            <button id="btnSubmitCustom" class="btn btn-primary">ğŸ“Œ é€å‡ºæ­£è§£</button>
          </div>
        </div>
      </div>

      <div class="footer">
        æé†’ï¼šç€è¦½å™¨ç„¡æ³•è®€å–ã€Œä½ é›»è…¦æœ‰å“ªäº›å­—å‹ã€çš„å®Œæ•´æ¸…å–®ï¼›æœ¬ç«™ç”¨å¸¸è¦‹å­—å‹æ¸…å–®å±•ç¤ºï¼Œä¸¦å…è¨±ä½ è‡ªè¡Œå®‰è£å­—å‹å¾Œæª¢æŸ¥é¡¯ç¤ºæ•ˆæœã€‚
      </div>
    </div>
  </div>

  <div id="toast" class="toast">å·²è¤‡è£½</div>

<script>
/* ===========================
   0) Firebase setup (YOU fill)
   =========================== */
const FIREBASE_ENABLED = true; // ä½ è¦å…ˆæŠŠ firebaseConfig å¡«å¥½
let db = null;

const firebaseConfig = {
  // TODO: é€™è£¡è²¼ä¸Šä½  Firebase å°ˆæ¡ˆ Web App çš„è¨­å®š
  // apiKey: "...",
  // authDomain: "...",
  // projectId: "...",
  // storageBucket: "...",
  // messagingSenderId: "...",
  // appId: "..."
};

function initFirebase(){
  try{
    if(!FIREBASE_ENABLED) return;
    if(!firebaseConfig || !firebaseConfig.projectId){
      console.warn("Firebase config missing. Disable FIREBASE_ENABLED or fill config.");
      return;
    }
    firebase.initializeApp(firebaseConfig);
    db = firebase.firestore();
  }catch(e){
    console.warn("Firebase init failed:", e);
    db = null;
  }
}

/* ===========================
   1) UI helpers
   =========================== */
const el = (id) => document.getElementById(id);

function toast(msg){
  const t = el("toast");
  t.textContent = msg;
  t.classList.add("show");
  setTimeout(()=>t.classList.remove("show"), 1200);
}

function setStatus(title, text){
  el("statusTitle").textContent = title;
  el("statusText").textContent = text;
}

function normalizeCharCandidates(text){
  // å–å‡ºã€Œçœ‹èµ·ä¾†åƒå­—ã€çš„å­—ç¬¦ï¼Œå»é™¤ç©ºç™½/æ§åˆ¶ç¬¦
  const arr = [];
  for(const ch of text){
    const code = ch.codePointAt(0);
    if(!code) continue;
    // éæ¿¾ç©ºç™½ã€æ§åˆ¶ç¬¦
    if(/\s/.test(ch)) continue;
    if(code < 0x20) continue;
    // éæ¿¾å¸¸è¦‹é›œè¨Šç¬¦è™Ÿï¼ˆå¯è¦–éœ€è¦èª¿æ•´ï¼‰
    if(ch === "ï¿½") continue;
    arr.push(ch);
  }
  return arr;
}

function uniqueCharsKeepOrder(chars){
  const seen = new Set();
  const out = [];
  for(const ch of chars){
    if(!seen.has(ch)){
      seen.add(ch);
      out.push(ch);
    }
  }
  return out;
}

/* ===========================
   2) Font list (practical set)
   =========================== */
const FONT_STACKS = [
  { name: "ç³»çµ±é è¨­", css: `system-ui, -apple-system, "PingFang TC", "Microsoft JhengHei", "Noto Sans CJK TC", "Noto Sans CJK SC", sans-serif` },
  { name: "PingFang TC", css: `"PingFang TC", system-ui, sans-serif` },
  { name: "PingFang SC", css: `"PingFang SC", system-ui, sans-serif` },
  { name: "Microsoft JhengHei", css: `"Microsoft JhengHei", system-ui, sans-serif` },
  { name: "Noto Sans CJK TC", css: `"Noto Sans CJK TC", system-ui, sans-serif` },
  { name: "Noto Sans CJK SC", css: `"Noto Sans CJK SC", system-ui, sans-serif` },
  { name: "Noto Serif CJK TC", css: `"Noto Serif CJK TC", serif` },
  { name: "SimSun", css: `"SimSun", serif` },
  { name: "PMingLiU", css: `"PMingLiU", serif` },
  { name: "HanaMinA", css: `"HanaMinA", serif` },
  { name: "BabelStone Han", css: `"BabelStone Han", serif` },
  { name: "Unifont", css: `"Unifont", monospace` },
];

/* ===========================
   3) "Can this font render this glyph?"
   - Best-effort heuristic:
     draw char in canvas with target font and with a fallback font,
     compare pixel hash. Not perfect but useful.
   =========================== */
function canvasGlyphHash(char, fontCss){
  const c = el("workCanvas");
  const ctx = c.getContext("2d", { willReadFrequently: true });
  const W = 120, H = 120;
  c.width = W; c.height = H;
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = "#fff";
  ctx.fillRect(0,0,W,H);

  ctx.fillStyle = "#000";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.font = `84px ${fontCss}`;
  ctx.fillText(char, W/2, H/2+4);

  const img = ctx.getImageData(0,0,W,H).data;
  // simple hash: sample grid 16x16, count dark pixels pattern
  let bits = "";
  const gx = 16, gy = 16;
  for(let y=0;y<gy;y++){
    for(let x=0;x<gx;x++){
      const px = Math.floor((x + 0.5) * W / gx);
      const py = Math.floor((y + 0.5) * H / gy);
      const idx = (py*W + px) * 4;
      const r = img[idx], g = img[idx+1], b = img[idx+2];
      const lum = (r*0.2126 + g*0.7152 + b*0.0722);
      bits += (lum < 200) ? "1" : "0"; // dark-ish
    }
  }
  // compress to hex-ish string
  let out = "";
  for(let i=0;i<bits.length;i+=4){
    out += parseInt(bits.slice(i,i+4),2).toString(16);
  }
  return out;
}

function glyphLikelyRendered(char, fontCss){
  // Compare against a "tofu-ish" fallback baseline.
  const h1 = canvasGlyphHash(char, fontCss);
  const h2 = canvasGlyphHash(char, `"Arial Unicode MS", "Segoe UI Symbol", sans-serif`); // broad fallback
  // If identical, could still be same tofu; compare to a known tofu char's hash as well.
  const tofu = "â–¡";
  const t1 = canvasGlyphHash(tofu, fontCss);
  // Heuristic: if char hash == tofu hash, likely not rendered
  if(h1 === t1) return false;
  // If h1 differs from fallback, more likely rendered
  return h1 !== h2 || h1 !== t1;
}

/* ===========================
   4) Image preprocessing to improve OCR
   =========================== */
async function preprocessImageToDataURL(img){
  const c = el("workCanvas");
  const ctx = c.getContext("2d", { willReadFrequently: true });

  // Fit to a reasonable size (OCR likes bigger)
  const maxW = 1400;
  const scale = Math.min(1, maxW / img.naturalWidth);
  const W = Math.max(1, Math.floor(img.naturalWidth * scale));
  const H = Math.max(1, Math.floor(img.naturalHeight * scale));
  c.width = W; c.height = H;

  ctx.drawImage(img, 0, 0, W, H);

  // grayscale + contrast + threshold
  const id = ctx.getImageData(0,0,W,H);
  const d = id.data;

  // Compute mean luminance
  let sum = 0;
  for(let i=0;i<d.length;i+=4){
    const lum = d[i]*0.2126 + d[i+1]*0.7152 + d[i+2]*0.0722;
    sum += lum;
  }
  const mean = sum / (d.length/4);

  // Adaptive-ish threshold around mean
  const thr = Math.max(80, Math.min(200, mean * 0.92));

  for(let i=0;i<d.length;i+=4){
    const lum = d[i]*0.2126 + d[i+1]*0.7152 + d[i+2]*0.0722;

    // Boost contrast slightly
    let v = (lum - mean) * 1.25 + mean;

    // Threshold
    v = (v > thr) ? 255 : 0;

    d[i]=d[i+1]=d[i+2]=v;
    d[i+3]=255;
  }
  ctx.putImageData(id,0,0);

  return c.toDataURL("image/png");
}

/* ===========================
   5) dHash image fingerprint for "learn over time"
   =========================== */
async function dhashFromImageDataURL(dataURL){
  const img = new Image();
  img.src = dataURL;
  await img.decode();

  const c = el("workCanvas");
  const ctx = c.getContext("2d", { willReadFrequently: true });

  // dHash: 9x8 grayscale compare horizontally => 64 bits
  const W = 9, H = 8;
  c.width = W; c.height = H;
  ctx.drawImage(img, 0, 0, W, H);
  const id = ctx.getImageData(0,0,W,H).data;

  const gray = [];
  for(let i=0;i<id.length;i+=4){
    const lum = id[i]*0.2126 + id[i+1]*0.7152 + id[i+2]*0.0722;
    gray.push(lum);
  }
  let bits = "";
  for(let y=0;y<H;y++){
    for(let x=0;x<8;x++){
      const left = gray[y*W + x];
      const right = gray[y*W + x + 1];
      bits += (left > right) ? "1" : "0";
    }
  }
  // to hex
  let hex = "";
  for(let i=0;i<bits.length;i+=4){
    hex += parseInt(bits.slice(i,i+4),2).toString(16);
  }
  return hex; // 16 hex chars
}

/* ===========================
   6) Firestore: store samples & stats
   =========================== */
async function getStatsForHash(phash){
  if(!db) return null;
  try{
    const doc = await db.collection("stats").doc(phash).get();
    return doc.exists ? doc.data() : null;
  }catch(e){
    console.warn("getStatsForHash failed:", e);
    return null;
  }
}

async function upsertStats(phash, chosenChar){
  if(!db) return;
  try{
    const ref = db.collection("stats").doc(phash);
    await db.runTransaction(async (tx)=>{
      const snap = await tx.get(ref);
      const data = snap.exists ? snap.data() : { counts: {}, updatedAt: firebase.firestore.FieldValue.serverTimestamp() };
      data.counts = data.counts || {};
      data.counts[chosenChar] = (data.counts[chosenChar] || 0) + 1;
      data.updatedAt = firebase.firestore.FieldValue.serverTimestamp();
      tx.set(ref, data, { merge: true });
    });
  }catch(e){
    console.warn("upsertStats failed:", e);
  }
}

async function logSample(payload){
  if(!db) return;
  try{
    await db.collection("samples").add({
      ...payload,
      createdAt: firebase.firestore.FieldValue.serverTimestamp(),
      userAgent: navigator.userAgent
    });
  }catch(e){
    console.warn("logSample failed:", e);
  }
}

/* ===========================
   7) OCR logic: multi-language + merge + 10 unique candidates
   =========================== */
let lastPreprocessedDataURL = null;
let lastPhash = null;
let lastOCRRaw = null;
let lastCandidates = [];

async function runOCR(preprocessedDataURL){
  if(!window.Tesseract) throw new Error("Tesseract.js not loaded");

  // Try multiple languages and merge results
  const langs = ["chi_tra", "chi_sim", "jpn"];
  const allText = [];
  const allConf = [];

  for(const lang of langs){
    setStatus("æ­£åœ¨è¾¨è­˜ä¸­â€¦", `OCR èªè¨€ï¼š${lang}ï¼ˆæœƒåˆä½µå€™é¸ï¼‰`);
    const worker = await Tesseract.createWorker(lang);
    try{
      // Some tuning
      await worker.setParameters({
        tessedit_pageseg_mode: "10", // treat as single char where possible
        preserve_interword_spaces: "1",
      });

      const { data } = await worker.recognize(preprocessedDataURL);
      if(data && data.text){
        allText.push(data.text);
      }
      // Pull symbol-level candidates if available
      if(data && data.symbols && data.symbols.length){
        for(const s of data.symbols){
          if(s.text) allConf.push({ ch: s.text, conf: s.confidence || 0 });
          if(s.choices && s.choices.length){
            for(const c of s.choices){
              if(c.text) allConf.push({ ch: c.text, conf: c.confidence || 0 });
            }
          }
        }
      }
    } finally {
      await worker.terminate();
    }
  }

  // 1) from symbol candidates (rank by confidence)
  const confChars = allConf
    .map(x => ({ ch: (x.ch || "").trim(), conf: x.conf }))
    .filter(x => x.ch && !/\s/.test(x.ch))
    .map(x => ({ ch: normalizeCharCandidates(x.ch)[0] || x.ch[0], conf: x.conf }))
    .filter(x => x.ch);

  // sort by conf desc
  confChars.sort((a,b)=>b.conf - a.conf);

  // 2) from raw texts
  const rawChars = uniqueCharsKeepOrder(
    allText.flatMap(t => normalizeCharCandidates(t))
  );

  // Merge into one list
  const merged = [];
  const seen = new Set();

  for(const item of confChars){
    if(!seen.has(item.ch)){
      seen.add(item.ch);
      merged.push(item.ch);
    }
    if(merged.length >= 25) break;
  }
  for(const ch of rawChars){
    if(!seen.has(ch)){
      seen.add(ch);
      merged.push(ch);
    }
    if(merged.length >= 25) break;
  }

  // Ensure we return 10 unique candidates.
  const top10 = merged.slice(0,10);

  return {
    langsTried: langs,
    texts: allText,
    top10,
    merged25: merged.slice(0,25)
  };
}

/* ===========================
   8) Render candidates + multi-font display + copy
   =========================== */
function codepointInfo(ch){
  const cp = ch.codePointAt(0);
  const hex = cp.toString(16).toUpperCase();
  const u = "U+" + hex.padStart(4,"0");
  return { cp, hex, u };
}

function renderCandidates(chars){
  const box = el("candidates");
  box.innerHTML = "";
  if(!chars || !chars.length){
    el("resultsInfo").textContent = "æ²’æœ‰å€™é¸çµæœã€‚è©¦è‘—æ›æ›´æ¸…æ¥šçš„åœ–ç‰‡æˆ–è£åˆ‡æˆåªå‰©ä¸€å€‹å­—ã€‚";
    el("feedbackBox").style.display = "none";
    return;
  }

  el("resultsInfo").textContent = `å·²ç”¢ç”Ÿ ${chars.length} å€‹å€™é¸å­—ï¼ˆé»å­—å¯è¤‡è£½ï¼‰ã€‚`;

  for(const ch of chars){
    const { u } = codepointInfo(ch);

    const card = document.createElement("div");
    card.className = "cand";

    const top = document.createElement("div");
    top.className = "candTop";

    const big = document.createElement("div");
    big.className = "bigChar";
    big.textContent = ch;
    big.title = "é»ä¸€ä¸‹è¤‡è£½";
    big.addEventListener("click", async ()=>{
      await navigator.clipboard.writeText(ch);
      toast(`å·²è¤‡è£½ï¼š${ch} (${u})`);
    });

    const meta = document.createElement("div");
    meta.className = "meta";
    meta.innerHTML = `<div>${u}</div><div class="tag">å€™é¸å­—</div>`;

    top.appendChild(big);
    top.appendChild(meta);

    const fonts = document.createElement("div");
    fonts.className = "fonts";

    for(const f of FONT_STACKS){
      const line = document.createElement("div");
      line.className = "fontLine";

      const name = document.createElement("div");
      name.className = "fontName";
      name.textContent = f.name;

      const sample = document.createElement("div");
      sample.className = "sample";
      sample.style.fontFamily = f.css;
      sample.textContent = ch;

      // best-effort rendered tag
      let ok = false;
      try{ ok = glyphLikelyRendered(ch, f.css); }catch(e){ ok = false; }
      const tag = document.createElement("span");
      tag.className = "tag";
      tag.textContent = ok ? "å¯èƒ½å¯é¡¯ç¤º" : "å¯èƒ½ä¸æ”¯æ´";

      const right = document.createElement("div");
      right.style.display = "flex";
      right.style.gap = "8px";
      right.style.alignItems = "center";
      right.appendChild(sample);
      right.appendChild(tag);

      line.appendChild(name);
      line.appendChild(right);
      fonts.appendChild(line);
    }

    card.appendChild(top);
    card.appendChild(fonts);
    box.appendChild(card);
  }

  renderFeedbackChoices(chars);
}

function renderFeedbackChoices(chars){
  const fb = el("feedbackBox");
  const grid = el("fbChoices");
  grid.innerHTML = "";
  fb.style.display = "grid";

  for(const ch of chars){
    const { u } = codepointInfo(ch);
    const item = document.createElement("div");
    item.className = "choice";
    item.innerHTML = `<div class="ch">${ch}</div><div><div class="small">${u}</div><div class="small">é»æˆ‘ï¼šé€™å€‹æœ€æ¥è¿‘</div></div>`;
    item.addEventListener("click", ()=>submitFeedback(ch, "pick"));
    grid.appendChild(item);
  }

  // "None of above"
  const none = document.createElement("div");
  none.className = "choice";
  none.innerHTML = `<div class="ch">âœ–</div><div><div class="small">ä»¥ä¸Šéƒ½ä¸æ˜¯</div><div class="small">ç”¨ä¸‹æ–¹è¼¸å…¥æ­£è§£</div></div>`;
  none.addEventListener("click", ()=>{
    el("fbCustom").focus();
  });
  grid.appendChild(none);
}

/* ===========================
   9) Feedback -> Firestore + re-rank stats
   =========================== */
async function submitFeedback(chosenChar, mode){
  const payload = {
    mode,
    chosenChar,
    phash: lastPhash || null,
    ocrRaw: lastOCRRaw || null,
    candidates: lastCandidates || null,
    page: location.href,
  };

  await logSample(payload);
  if(lastPhash) await upsertStats(lastPhash, chosenChar);

  toast(`å·²å›é¥‹ï¼š${chosenChar}`);
  // show chosen char as "manual" display too (nice UX)
  el("manualChar").value = chosenChar;
  el("manualCode").value = "";
  renderCandidates([chosenChar, ...lastCandidates.filter(c=>c!==chosenChar)].slice(0,10));
}

function parseManualInputToChar(){
  const rawChar = (el("manualChar").value || "").trim();
  if(rawChar){
    // take first code point
    const cp = rawChar.codePointAt(0);
    return String.fromCodePoint(cp);
  }
  const rawCode = (el("manualCode").value || "").trim();
  if(!rawCode) return null;

  let hex = rawCode.toUpperCase();
  hex = hex.replace(/^U\+/, "").replace(/^0X/, "");
  if(!/^[0-9A-F]+$/.test(hex)) return null;

  const cp = parseInt(hex, 16);
  if(!Number.isFinite(cp) || cp <= 0 || cp > 0x10FFFF) return null;
  return String.fromCodePoint(cp);
}

/* ===========================
   10) Main flows
   =========================== */
let currentImageURL = null;

async function handleFile(file){
  if(!file) return;
  if(currentImageURL) URL.revokeObjectURL(currentImageURL);
  currentImageURL = URL.createObjectURL(file);
  const img = el("previewImg");
  img.src = currentImageURL;
  img.style.display = "block";
  await img.decode();

  el("btnRecognize").disabled = false;
  el("btnRetry").disabled = false;
  setStatus("å·²ä¸Šå‚³åœ–ç‰‡", "æŒ‰ã€Œé–‹å§‹è¾¨è­˜ã€ä¾†åš OCRã€‚å»ºè­°å…ˆè£åˆ‡åˆ°åªå‰©å–®ä¸€å­—ï¼Œæº–ç¢ºç‡æœƒé¡¯è‘—æå‡ã€‚");
}

async function recognizeFromPreview(){
  const img = el("previewImg");
  if(!img.src) return;

  el("btnRecognize").disabled = true;
  el("btnRetry").disabled = true;
  setStatus("æº–å‚™ä¸­â€¦", "æ­£åœ¨åšå½±åƒå‰è™•ç†ï¼ˆé»‘ç™½åŒ– / æå‡å°æ¯”ï¼‰");

  const pre = await preprocessImageToDataURL(img);
  lastPreprocessedDataURL = pre;

  setStatus("æº–å‚™ä¸­â€¦", "æ­£åœ¨å»ºç«‹åœ–ç‰‡æŒ‡ç´‹ï¼ˆè¶Šç”¨è¶Šæº–æœƒç”¨åˆ°ï¼‰");
  lastPhash = await dhashFromImageDataURL(pre);

  // Try to pull stats to re-rank later
  let stats = await getStatsForHash(lastPhash);

  setStatus("OCR é€²è¡Œä¸­â€¦", "æœƒä¾åºå˜—è©¦ chi_tra / chi_sim / jpnï¼Œä¸¦åˆä½µå€™é¸ã€‚");
  let ocrRes;
  try{
    ocrRes = await runOCR(pre);
  }catch(e){
    console.error(e);
    setStatus("è¾¨è­˜å¤±æ•—", "OCR è¼‰å…¥æˆ–åŸ·è¡Œå¤±æ•—ã€‚è«‹ç¢ºèªç¶²è·¯å¯è¼‰å…¥ Tesseract.jsï¼Œæˆ–æ›å¼µæ›´æ¸…æ¥šçš„åœ–ã€‚");
    el("btnRecognize").disabled = false;
    el("btnRetry").disabled = false;
    return;
  }

  lastOCRRaw = ocrRes;
  // Ensure 10 candidates (unique)
  let cand = uniqueCharsKeepOrder(ocrRes.top10).slice(0,10);

  // If stats exist: reorder by learned counts
  if(stats && stats.counts){
    const counts = stats.counts;
    cand.sort((a,b)=>(counts[b]||0)-(counts[a]||0));
  }

  // If less than 10, pad with merged25 unique
  if(cand.length < 10){
    const more = uniqueCharsKeepOrder(ocrRes.merged25);
    for(const ch of more){
      if(!cand.includes(ch)){
        cand.push(ch);
        if(cand.length >= 10) break;
      }
    }
  }

  lastCandidates = cand;

  // Log sample (auto) for later analysis
  await logSample({
    mode: "ocr",
    phash: lastPhash,
    ocrRaw: lastOCRRaw,
    candidates: lastCandidates,
    page: location.href,
  });

  setStatus("å®Œæˆ âœ…", `å·²ç”¢ç”Ÿå€™é¸å­—ã€‚åœ–ç‰‡æŒ‡ç´‹ï¼š${lastPhash}`);
  renderCandidates(lastCandidates);

  el("btnRecognize").disabled = false;
  el("btnRetry").disabled = false;
}

async function retryOCR(){
  // same as recognize, but doesn't require re-upload
  await recognizeFromPreview();
}

/* ===========================
   11) Boot
   =========================== */
window.addEventListener("DOMContentLoaded", ()=>{
  initFirebase();

  el("fileInput").addEventListener("change", (e)=>{
    const file = e.target.files && e.target.files[0];
    handleFile(file);
  });

  el("btnRecognize").addEventListener("click", recognizeFromPreview);
  el("btnRetry").addEventListener("click", retryOCR);

  el("btnManualShow").addEventListener("click", ()=>{
    const ch = parseManualInputToChar();
    if(!ch){
      toast("è«‹å…ˆè²¼ä¸Šå­—ï¼Œæˆ–è¼¸å…¥ U+XXXX");
      return;
    }
    const chars = [ch];
    lastCandidates = chars;
    renderCandidates(chars);
    setStatus("æ‰‹å‹•æ¨¡å¼ âœ…", "å·²é¡¯ç¤ºä½ è¼¸å…¥çš„å­—ï¼ˆé»å­—å³å¯è¤‡è£½ï¼‰ã€‚");
  });

  el("btnClear").addEventListener("click", ()=>{
    el("manualChar").value = "";
    el("manualCode").value = "";
    el("previewImg").src = "";
    el("previewImg").style.display = "none";
    el("candidates").innerHTML = "";
    el("resultsInfo").textContent = "å°šç„¡çµæœã€‚ä¸Šå‚³åœ–ç‰‡æˆ–æ‰‹å‹•è¼¸å…¥å¾Œï¼Œæœƒåœ¨é€™è£¡å‡ºç¾å€™é¸å­—å¡ç‰‡ã€‚";
    el("feedbackBox").style.display = "none";
    el("btnRecognize").disabled = true;
    el("btnRetry").disabled = true;
    setStatus("å°šæœªä¸Šå‚³åœ–ç‰‡", "ä¸Šå‚³å¾ŒæŒ‰ã€Œé–‹å§‹è¾¨è­˜ã€ï¼Œæœƒç”¢ç”Ÿ 10 å€‹ä¸åŒå€™é¸å­—ã€‚");
  });

  el("btnSubmitCustom").addEventListener("click", async ()=>{
    const raw = (el("fbCustom").value || "").trim();
    if(!raw){
      toast("è«‹è¼¸å…¥æ­£ç¢ºå­—æˆ– U+XXXX");
      return;
    }

    // parse as char or codepoint
    let chosen = null;
    if(/^U\+|^0x|^[0-9a-fA-F]+$/.test(raw)){
      // maybe code
      el("manualChar").value = "";
      el("manualCode").value = raw;
      chosen = parseManualInputToChar();
    }else{
      chosen = raw.codePointAt(0) ? String.fromCodePoint(raw.codePointAt(0)) : null;
    }

    if(!chosen){
      toast("æ ¼å¼ä¸æ­£ç¢ºã€‚è«‹è¼¸å…¥å­—ï¼Œæˆ– U+XXXX / 4E00 / 0x4E00");
      return;
    }

    await submitFeedback(chosen, "custom");
    el("fbCustom").value = "";
  });
});
</script>

</body>
</html>

